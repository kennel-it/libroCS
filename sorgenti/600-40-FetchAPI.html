<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html>
<!-- autoIndex requires="elaborazioneJsonClient richiestaHttp rispostaHttp architettureServizi" group="javascript" coords="70,60" -->
<!-- changelog 2024-04-22 inserita prima parte dei contenuti -->
<!-- changelog 2024-04-28 completato capitolo -->
<html xmlns="http://www.w3.org/1999/xhtml">
   <head>
   	<meta charset="UTF-8"/>
       <title>FetchAPI</title>
       <link type="text/css" rel="stylesheet" href="style.css"/>
       <script type="text/javascript" src="script/test.js"></script>
   </head>
<body>
<header>
    <h1>FetchAPI</h1>
    <p>recuperare risorse remote con javascript</p>
</header>
<article>
    <p><a href="https://developer.mozilla.org/it/docs/Web/API/Fetch_API">Fetch API</a>
    è una modalità per accedere a risorse remote usando dei meccanismi
    asincroni anche in maniera semplificata.
    In questo capitolo faremo uso sia di fetch API che delle istruzioni
    <code>async</code> <code>await</code> di Javascript.
    Non è necessario usare async await ma ci
    semplifica non poco la scrittura dei programmi.</p>

    <p>Per fare una richiesta remota è possibile usare il metodo<code>fetch()</code>
    che ha come parametro l'indirizzo della risorsa che vogliamo
    e ritorna come risultato un oggetto di tipo
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a>
    che di per se indica una operazione che prima o poi verrà completata
    (è pur sempre una richiesta in rete... ha bisogno di qualche millesimo di secondo!)
    o fallirà.</p>

    <p>È possibile utilizzare l'oggetto Promise ottenuto per indicare cosa va fatto una volta
    che l'operazione (la comunicaizone in rete nel nostro caso)
    è terminata ma è più semplice utilizzare l'istruzione <code>await</code>.</p>

    <p><code>let risposta = await fetch("https://x.y.x/risorsa");</code></p>

    <p><code>await</code> fa in modo che l'esecuzione del nostro script venga sospesa
    e riprenda soltanto quando la Promise viene completata
    (sarebbe a dire che la risorsa è arrivata nel caso della fetch). La gestione asincrona
    in pratica la fa il browser. Da tener presente però che
    se usiamo await la funzione che contiene questa istruzione
    va dichiarata come <code>async</code> per marcarla come asincrona.</p>

    <p>L'oggetto Promise restituito da <code>fetch()</code> se tutto va bene
    si risolve in un oggetto di tipo
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response">Response</a>
    quindi nell'esempio sopra <code>risposta</code> è un oggetto <code>Response</code>
    che tra gli altri ha un comodo metodo <code>json()</code> per convertire
    il corpo della risposta da JSON ad oggetto.</p>

    <p><code>let oggetto = await risposta.json();</code></p>

    <p>A sua volta il metodo <code>json()</code> restituisce un oggetto Promise che in assenza
    di errori si risolve in un oggetto javascript che viene costruito in base
    al testo JSON presente nel corpo della risposta.</p>

	<p>Mettendo insieme le parti, una semplice funzione che recupera un oggetto
    memorizzato su un server remoto potrebbe essere:</p>

<pre><code>
<em>async</em> function recuperaInformazioni() {
    <em>let risposta = await fetch("https://x.y.z/risorsa.json");</em>
    <em>let libro = await risposta.json();</em>
    console.log(libro.titolo);
}
</code></pre>

    <h2>Invio dei dati al server</h2>
    <p>Il metodo
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/fetch">fetch()</a>
    ha in realtà due parametri: il primo è la URL
    della risorsa che ci interessa (già visto nella sezione precedente)
    e il secondo è un oggetto che ci permette di specificare
    alcuni parametri della richiesta tra cui abbiamo:</p>
    <dl>
        <dt>method</dt>
        <dd>un metodo di HTTP</dd>
        <dt>headers</dt>
        <dd>un oggetto che rappresenta i diversi headers che vogliamo inserire</dd>
        <dt>body</dt>
        <dd>il corpo della richiesta, può essere scritto in diversi
        formati tra cui anche una stringa di testo (utile per mandare contenuto JSON)</dd>
    </dl>

    <p>Un caso comune è quello in cui si vuole inviare un oggetto al server
    per poterlo archiviare
    rappresentandolo come JSON nel corpo della richiesta. Una possibile soluzione
    è quella di creare un oggetto specificando il metodo (POST), un header
    che descrive il media type del corpo (che è in JSON) e il corpo stesso, successivamente
    si chiama la funzione fetch specificando sia la url del servizio che i parametri
    appena definiti.</p>

<pre><code>
async function recuperaInformazioni() {
    <em>let parametriRichiesta = {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(oggettoDaInviare)
    };</em>
    let risposta = await fetch("https://x.y.z/inserisci",<em>parametriRichiesta</em>);
    /* ... */
}
</code></pre>

    <h2>Gestione degli errori</h2>
    <p>Finora abbiamo gestito la comunicazione con fetch API considerando
    ingenuamente che vada tutto bene: il che però è poco realistico. L'istruzione
    <code>await</code> in caso che l'oggetto Promise che sta gestendo
    non si risolve positivamente solleva una eccezione che può essere gestita
    utilizzando il costrutto try/catch. L'oggetto che rappresenta
    il problema che si è verificato ha diverse proprietà, due delle quali
    potrebbero essere utili per capire la natura del problema stesso:
    <code>name</code> e <code>message</code>.</p>

<pre><code>
async function richiestaRealista(){
    <em>try{</em>
        let risposta = await fetch(URL_ORARI);
        let oggetto = await risposta.json();
        /* ... */
    <em>}catch(e){</em>
        console.log(<em>e.name</em>);
        console.log(<em>e.message</em>);
    <em>}</em>
}
</code></pre>
</article>
</body>
</html>
