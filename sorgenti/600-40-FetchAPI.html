<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html>
<!-- autoIndex requires="elaborazioneJsonClient richiestaHttp rispostaHttp architettureServizi" group="javascript" coords="70,60" -->
<!-- changelog 2024-04-22 inserita prima parte dei contenuti -->
<!-- changelog 2024-04-28 completato capitolo -->
<!-- changelog 2025-08-29 aggiunta parte di approfondimento su Promise -->
<!-- changelog 2025-09-12 messa parte su campi ok e status della risposta -->
<html xmlns="http://www.w3.org/1999/xhtml">
   <head>
   	<meta charset="UTF-8"/>
       <title>FetchAPI</title>
       <link type="text/css" rel="stylesheet" href="style.css"/>
       <script type="text/javascript" src="script/test.js"></script>
   </head>
<body>
<header>
    <h1>FetchAPI</h1>
    <p>recuperare risorse remote con javascript</p>
</header>
<article>
    <h2>fetch &amp; async</h2>
    <p>Parlando di comunicazione (e in genere di operazioni onerose dal punto di vista
    del tempo di completamento) spesso si usano delle tecniche asincrone.
    In questo contesto quello che vogliamo evitare è che il programma si
    blocchi in attesa che l'operazione venga completata.
    Per ovviare a questo problema
    una possibile via di uscita è fare in modo che la parte di programma
    che ha bisogno del risultato del lavoro lento venga sospesa
    e riprenda quando l'operazione è stata completata, in alternativa
    si può fornire una funzione da chiamare una volta che il risultato
    è disponibile. A ben guardare le differenze sono più di tipo sintattico
    che altro.</p>

    <p><a href="https://developer.mozilla.org/it/docs/Web/API/Fetch_API">Fetch API</a>
    è una modalità per accedere a risorse remote usando dei meccanismi
    asincroni in maniera semplificata.
    In questo capitolo faremo uso sia di fetch API che delle istruzioni
    <code>async</code> <code>await</code> di Javascript.
    Non è necessario usare async await ma ci
    semplifica non poco la scrittura dei programmi.</p>

    <p>Per fare una richiesta remota è possibile usare il metodo<code>fetch()</code>
    che ha come parametro l'indirizzo della risorsa che vogliamo
    e ritorna come risultato un oggetto di tipo
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a>
    che di per sé indica una operazione che prima o poi verrà completata
    (è pur sempre una richiesta in rete... ha bisogno di qualche millesimo di secondo!)
    o fallirà.</p>

    <p>È possibile utilizzare l'oggetto Promise ottenuto per indicare cosa va fatto una volta
    che l'operazione (la comunicazione in rete nel nostro caso)
    è terminata ma è più semplice utilizzare l'istruzione <code>await</code>.</p>

    <p><code>let risposta = await fetch("https://x.y.x/risorsa");</code></p>

    <p><code>await</code> fa in modo che l'esecuzione del nostro script venga sospesa
    e riprenda soltanto quando la Promise viene completata
    (sarebbe a dire che la risorsa è arrivata nel caso della fetch). La gestione asincrona
    in pratica la fa il browser. Da tener presente però che
    se usiamo <code>await</code> la funzione che contiene questa istruzione
    va dichiarata come <code>async</code> per marcarla come asincrona.</p>

    <p>L'oggetto Promise restituito da <code>fetch()</code> se tutto va bene
    si risolve in un oggetto di tipo
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response">Response</a>
    quindi nell'esempio sopra <code>risposta</code> è un oggetto <code>Response</code>
    che tra gli altri ha un comodo metodo <code>json()</code> per convertire
    il corpo della risposta da JSON ad oggetto.
    Il metodo <code>json()</code> in effetti restituisce un oggetto Promise 
    (asincrono perché il decoding potrebbe richiedere tempo) che in assenza
    di errori si risolve in un oggetto javascript che viene costruito in base
    al testo JSON presente nel corpo della risposta.</p>

    <p><code>let oggetto = await risposta.json();</code></p>

	<p>Mettendo insieme le parti, una semplice funzione che recupera un oggetto
    memorizzato su un server remoto potrebbe essere:</p>

<pre><code>
<em>async</em> function recuperaInformazioni() {
    <em>let risposta = await fetch("https://x.y.z/risorsa.json");</em>
    <em>let libro = await risposta.json();</em>
    console.log(libro.titolo);
}
</code></pre>

    <h2>Invio dei dati al server</h2>
    <p>Il metodo
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/fetch">fetch()</a>
    ha in realtà due parametri: il primo è la URL
    della risorsa che ci interessa (già visto nella sezione precedente)
    e il secondo è un oggetto che ci permette di specificare
    alcuni parametri della richiesta tra cui abbiamo:</p>
    <dl>
        <dt>method</dt>
        <dd>un metodo di HTTP</dd>
        <dt>headers</dt>
        <dd>un oggetto che rappresenta i diversi headers che vogliamo inserire</dd>
        <dt>body</dt>
        <dd>il corpo della richiesta, può essere scritto in diversi
        formati tra cui anche una stringa di testo (utile per mandare contenuto JSON)</dd>
    </dl>

    <p>Un caso comune è quello in cui si vuole inviare un oggetto al server
    (ad esempio per poterlo archiviare)
    rappresentandolo come JSON nel corpo della richiesta. Una possibile soluzione
    è quella di creare un oggetto che descrive la richiesta specificando:</p>
    <ul>
        <li>il metodo, POST nel nostro caso</li>
        <li>gli headers, soltanto il tipo mime nell'esempio</li>
        <li>il corpo del messaggio che qui sotto otteniamo rappresentando
        in JSON un oggetto che già abbiamo</li>
    </ul>
    <p>Nel chiamare <code>fetch()</code> fornisco come parametri la URL del servizio 
    e i parametri della richiesta appena definiti.</p>

<pre><code>
async function inviaDati(oggettoDaInviare) {
    <em>let parametriRichiesta = {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(oggettoDaInviare)
    };</em>
    let risposta = await fetch("https://x.y.z/inserisci",<em>parametriRichiesta</em>);
    /* ... */
}
</code></pre>

    <h2>Gestione degli errori</h2>
    <p>Finora abbiamo gestito la comunicazione con fetch API considerando
    ingenuamente che vada tutto bene: il che però è poco realistico. L'istruzione
    <code>await</code> in caso che l'oggetto Promise che sta gestendo
    non si risolve positivamente solleva una eccezione che può essere gestita
    utilizzando il costrutto try/catch. L'oggetto che rappresenta
    il problema che si è verificato ha diverse proprietà, due delle quali
    potrebbero essere utili per capire la natura del problema stesso:
    <code>name</code> e <code>message</code>.</p>

<pre><code>
async function richiestaRealista(){
    <em>try{</em>
        let risposta = await fetch(URL_ORARI);
        let oggetto = await risposta.json();
        /* ... */
    <em>}catch(e){</em>
        console.log(<em>e.name</em>);
        console.log(<em>e.message</em>);
    <em>}</em>
}
</code></pre>

    <p>Attenzione ad una cosa: se il server risposnde con un <code>404</code>
    questo non solleva eccezioni: la comunicazione si è conclusa e quello che abbiamo
    ottenuto è una risposta che magari indica un errore.
    Per testare la risposta del server possiamo usare il campo <code>ok</code>
    dell'oggetto <code>Response</code> restituito da fetch(). <code>ok</code>
    sarà <code>true</code> se la risposta ha come codice un numero nel range 200-299.</p>
    <p>Per evere maggior dettaglio è possibile usare le proprietà
    <code>status</code> e <code>statusText</code> sempre della risposta.</p>

<div class="approfondimento">
    <h3>Promise</h3>
    <p>In questo capitolo abbiamo usato <code>async/await</code> in pratica per non usare
    gli oggetti <em>Promise</em>, vediamo però come si potrebbero usare direttamente.
    La differenza sta nel come gestisce il fatto che le operazioni sono asincrone.</p>
    
    <p>Un oggetto Promise rappresenta un compito che impiega
    tempo per essere completato e che può finir bene o meno, può trovarsi in tre stati:</p>
    <dl>
        <dt>pending</dt>
        <dd>lo stato iniziale, è ancora al lavoro/in attesa</dd>
        <dt>fulfilled</dt>
        <dd>operazioni completate con successo</dd>
        <dt>rejected</dt>
        <dd>operazioni finite perché ci sono stati problemi</dd>
    </dl>
    
    <p>Una volta che abbiamo l'oggetto <code>Promise</code> con il metodo <code>then()</code> possiamo
    passare due funzioni (la seconda è opzionale) che verranno chiamate se le
    cose sono andate bene (la prima) o se le cose sono andate male (la seconda).
    Vediamo la sola richiesta di una risorsa remota usando <code>fetch()</code>
    </p>
    
<pre><code>
fetch("https://server.sito.it/risorsa")
  .<em>then(</em>
    <span style="color:green">// questa funzione viene chiamata se la richiesta è andata a buon fine
    risposta => {
      if (risposta.ok) {
        // elaboro la risposta
        console.log(risposta.body);
      } else {
        console.log('stato:', risposta.status, risposta.statusText);
      }
    }</span>,
    <span style="color:red">// questa funzione viene chiamata in caso di errore
    errore => {
      console.log('errore nella comunicazione:', errore);
    }</span>
  );
</code></pre>
    <p>Attenzione ad una cosa: per quanto riguarda <code>fetch()</code>
    se il server risponde (anche un 404) si considera comunque <em>fullfilled</em>.</p>

    <p>Spesso lo scopo è quello di avere l'oggetto Javascript che il server ci ha mandato
    come JSON, in questo caso il lavoro non è ancora finito. Dobbiamo convertire il corpo
    in un oggetto: di nuovo una operazione asincrona (del resto l'altro modo di farlo
    che abbiamo visto usavaa <code>await</code>). Siccome stiamo lavorando con
    Promise basta aggiungere ancora un <code>then()</code>:</p>

<pre><code>
fetch(URL)
  .then(
    risposta => {
      if (risposta.ok) {
        // elaboro la risposta: converto da json
        <em>return risposta.json(); // che è di nuovo Promise</em>
      } else {
        console.log('stato:', risposta.status, risposta.statusText);
      }
    },
    errore => {
      console.log('err comunicazione:', errore);
    }
  )
  <em>.then(
    oggetto => {
      console.log(oggetto.lunghezza);
    },
    errore => {
      console.log('err JSON:', errore);
    }
  )</em>;
</code></pre>

    <p>Complicato? però possiamo semplificare usando <code>catch()</code>
    in fondo alla catena per intercettare tutti gli errori,
    sia che vengono dal primo then che dal secondo
    se non sono stati gestiti cioè se non è stata
    fornita la seconda funzione al <code>then()</code>.</p>

<pre><code>
fetch(URL)
  .then(
    risposta => {
      if (risposta.ok) {
        // elaboro la risposta: converto da json
        return risposta.json(); // che è di nuovo Promise
      } else {
        <em>// visto che ci siamo considero anche questo un errore
        throw new Error('Risposta non OK');</em>
      }
    }
  )
  .then(
    oggetto => {
      console.log(oggetto.lunghezza);
    }
  )
  <em>.catch(errore => {
    console.log('err generale:', errore);
  })</em>;
</code></pre>
</div>
</article>
</body>
</html>
