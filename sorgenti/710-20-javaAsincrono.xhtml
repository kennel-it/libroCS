<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html>
<!-- grafoIndice requires="javaSocket" group="java" -->
<!-- changelog 2017-11-11 inserito capitolo -->
<!-- changelog 2017-11-15 primo blocco di contenuti -->
<!-- changelog 2018-11-04 specificata funzione di Thread.start() -->
<!-- changelog 2018-11-06 riorganizzato tutto il capitolo -->
<!-- changelog 2018-11-11 aggiunto blocco importante -->
<html xmlns="http://www.w3.org/1999/xhtml">
   <head>
   	<meta charset="UTF-8"/>
       <title>javaAsincrono</title>
       <link type="text/css" rel="stylesheet" href="style.css"/>
       <script type="text/javascript" src="script/test.js"></script>         
   </head>
<body>
<header>
	<h1>javaAsincrono</h1>
	<p>fare più cose contemporaneamente</p>
</header>
<article>

    <h2>Il problema</h2>
    <p>Dovremmo piuttosto parlare al plurale, poter svolgere più operazioni contemporaneamente
    (a questo serve il multithreading) risulta utile in più spesso di quanto si possa pensare... 
    ad esempio:</p>
    <ul>
        <li>voglio portare a termine un lavoro più velocemente</li>
        <li>devo tener d'occhio una situazione mentre faccio altro</li>
    </ul>

    <p>In entrambe i casi il problema non è tanto avviare un esecutore per il secondo compito
    quanto capire come poter dividere il compito in dueo o non creare collisioni quando 
    si va a modificare un dato condiviso. Proviamo ad analizzare un caso alla volta partendo 
    da quello che ci aiuta as essere più veloci.</p>
    
    <h2>Calcolo parallelo</h2>
    <p>Prendiamo come esempio un problema: voglio calcolare il minimo valore presente in un vettore.</p>
    <p>Questo problema (come molti altri) si presta molto bene ad essere elaborato in parallelo:</p>
<pre>
v vettore di n elementi
m1 = calcolo il minimo di v dalla posizione 0 alla posizione n/2
m2 = calcolo il minimo di v dalla posizione n/2+1 alla posizione n-1
minimo = minimo tra m1 e m2
</pre>

    <p>In questo caso il calcolo di m1 e m2 si presta molto bene ad essere eseguito in parallelo,
    alla fine possiamo molto velocemente calcolare il minimo.</p>
    
    <h3>Minimo</h3>
    <p>Ci ricordiamo tutti come si calcola il minimo valore presente in un vettore vero?
    però a scanso di equivoci...</p>

<pre>
public int minimo(int v[]){
    int min = minimo[0];
    for(int i=1; i&lt;v.length; i++){
        if(v[i]&lt;min){
            min = v[i];
        }
    }
    return min;
}
</pre>    
    
    <p>In effetti a noi fa comodo una sua (poco significativa dal punto di vista algoritmico) 
    variazione:</p>
<pre>
public int minimo(int v[], int primo, int ultimo){
    int min = minimo[primo];
    for(int i=primo+1; i&lt;=ultimo; i++){
        if(v[i]&lt;min){
            min = v[i];
        }
    }
    return min;
}
</pre>    
    <p>In pratica abbiamo solo reso esplicito quale parte del vettore va considerata, 
    questo ci farà comodo per <i>dividere</i> il problema in due parti.</p> 
    
    <h3>Minimo parallelo</h3>
    <p>Da qui in avanti sono tutti dettagli implementativi per trattare con le clasi che Java ci mette
    a disposizione, potremmo usare diversi approcci ma per semplicità adesso usiamo la classe
    <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html"><code>java.lang.Thread</code></a>
    e senza troppe ottimizzazioni la classe che avvia i due thread una volta avviati aspetterà che
    questi completino il lavoro prima di andare avanti.</p>
 
    <p>Iniziamo dalla classe che calcola il minimo: questa classe estende <code>Thread</code>
    e definisce tre metodi:</p>
    <dl>
        <dt>Cercatore</dt>
        <dd>è il costruttore e semplicemente richiede che per creare un Cercatore serve di sapere
        su quale vettore lavorare e anche su quale intervallo di posizioni.</dd>
        <dt><em>run</em></dt>
        <dd>questo metodo è quello che fa tutto il lavoro, quando termina il thread stesso
        viene chiuso</dd>
        <dt>getMinimo</dt>
        <dd>è il metodo che ci fornisce il risultato... ovviamente va chiamato quando il 
        thread a finito il suo lavoro, chiamarlo prima non avrebbe senso.</dd>
    </dl>    
<pre>
public class Cercatore <em>extends Thread</em> {
    private int inizio, fine;
    private int[] sequenza;
    private int minimo;

    public Cercatore(int inizio, int fine, int[] sequenza) {
        this.inizio = inizio;
        this.fine = fine;
        this.sequenza = sequenza;
    }

    <em>@Override
    public void run()</em>{
        minimo=sequenza[inizio];
        for(int i = inizio ; i &lt; fine ; i++){
            if(sequenza[i] &lt; minimo){
                minimo=sequenza[i];
            }
        }
    }
       
    public int getMinimo(){
        return minimo;
    }
}
</pre>
    
    <h3>Gestore dei thread</h3>
    <p>Bene, adesso abbiamo un lavoratore che cerca il minimo... e magari abbiamo un processore
    con più di un nucleo di elaborazione: come sfruttiamo la situazione?
    Costruendo un programma che usa il Cercatore!</p>
    
<pre>
public class MinimoNumero {

    public static void main(String[] args) throws InterruptedException{

        int sequenza[] = new int[10_0000_000];
        // carico una sequenza casuale, per provare
        for(int i=0; i &lt; sequenza.length; i++) {
            sequenza[i] = (int)(Math.random() * 10000000);
        }
        
        //Creo i Threads
        Cercatore cercatore1 = new Cercatore(0, 49999999, sequenza);
        Cercatore cercatore2 = new Cercatore(50000000, 99999999, sequenza);
        
        // li avvio
        cercatore1.start();
        cercatore2.start();
        System.out.println("Threads avviati!");
        
        // attendo la fine del primo thread
        cercatore1.join();
        // attendo la fine del secondo thread
        cercatore2.join();
        System.out.println("Lavoro finito");
        
        // recupero i risultati
        int minimoThread1 = cercatore1.getMinimo();
        int minimoThread2 = cercatore2.getMinimo();
        
        if(minimoThread1 &lt; minimoThread2) {
            System.out.println(minimoThread1);
        }else {
            System.out.println(minimoThread2);
        }
    }
}
</pre>

    <p>Per chiarezza dobbiamo precisare che: questo programma potrebbe essere scritto in maniera più 
    furba! (magari senza bloccarsi) e che un processore attuale lo esegue in tempi brevissimi.
    Lo stesso identico schema può però ad esempio essere usato per ruotare una scana 3D, in questo
    caso avere 4 nuclei (o più) di elaborazione e sfruttarli bene fa la differenza.</p>
        
    
    
    
    <div class="errore">TODO: piazza la roba qui sotto da qualche parte<br/>o comunque sistemala</div>
	<h2>Il problema</h2>
	<p>Nella comunicazione client/server non tutto avviene in maniera sincrona!</p>
	<p>Gestire la comunicazione nel caso in cui io invio un messaggio e subito
	dopo leggo la risposta non è molto di complicato... il problema nasce
	quando l'invio di un messagio da parte del server avviene in un momento non predicibile
	(e questa avviene in moltissimi casi).
	Questo è un problema perché se il nostro programma attende l'input dell'utente non può
	allo stesso tempo attendere i messaggi dal server, nel caso contrario se si fermasse in
	attesa dei messaggi l'interfaccia grafica non risponderebbe all'input dell'utente.</p>
	
	<h2>Thread</h2>
	<p>Possiamo però fare in modo che il nostro programma si divida in due flussi di elaborazione: 
	uno per gestire l'input dell'utente e l'altro per attendere i messaggi dal server.
	Per fare questo abbiamo bisogno di utilizzare la classe 
	<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html"><code>java.lang.Thread</code></a>.</p>
	<p>L'oggetto <code>Thread</code> va esteso e in particolare va implementato il suo metodo <code>run()</code>
	dentro il quale scriverremo la parte di programma che deve essere useguita nel thread separato... in pratica:</p>	
	
<pre>
public class Esecutore extends Thread {

	@Override
	public void run(){
		// codice da eseguire nel thread		
	}
}
</pre>

	<p>Ora per creare un nuovo oggetto <code>Esecutore</code> si procede come con tutti gli altri oggetti:
	<code>Esecutore x = new Esecutore();</code>
	</p>

	<p>A questo punto il thread è stato creato ma non avviato, questo va fatto esplicitamente usando
	il metodo start:<code>x.start();</code></p>
	
	<p>Il programma che ha creato il thread continuerà nel normale flusso delle istruzioni e parallelamente
	verrà avviato il nuovo thread che terminerà quando uscirà dal metodo <code>run()</code>.</p>

	<div class="test">
	   	<p>l'istruzione <code>x.start()</code>...</p>
	    <a onclick="sbagliata(this)">è errata (Esecutore non definisce start)<span class="spiegazione">no, potrebbe averla definita qualcun'altro</span></a> 
	    <a onclick="giusta(this)">è giusta<span class="spiegazione">si, viene definita da Thread</span></a> 
	</div>
	
<p>Creazione e avvio del nuovo thread vanno fatta ovviamente in una classe diversa, ad esempio:</p>
<pre>
public class ClassePrincipale {

	// possibili impostazioni dell'interfaccia e quant'altro...

	public void avvireNuovoThread(){
		Esecutore nuovoThread = new Esecutore();
		// eventuali impostazioni dell'oggetto appena creato
		// come ad esempio il passaggio di un oggetto dove
		// visualizzare l'output
		nuovoThread.start();
	}
}
</pre>

<h2>JavaFX</h2>
<p>Ci crea qualche complessità in più perché ci impone un vincolo: 
non è possibile modificare l'interfaccia grafica di JavaFX 
da un thread diverso rispetto a quello di JavaFX.</p>
<p>Il problema è che il nostro codice viene in generale eseguito in un thread che
non è quello di JavaFX, gli sviluppatori della piattaforma ci hanno però messo ad disposizione un 
oggetto che ci permette di inviare dei lavori da eseguire al thread di JavaFX: l'oggetto
in questione si chiama 
<a href="https://openjfx.io/javadoc/11/javafx.graphics/javafx/application/Platform.html">
<code>javafx.application.Platform</code></a> e in particolare per fare il lavoro che ci serve
ci interessa il suo metodo statico <code>runLater​()</code>.</p>
<p><code>runLater</code> si comporta un po' come il <code>setOnAction</code> che si usa per impostare
l'azione da legare ad un pulsante, l'unica differenza è che questo metodo non ha parametri
(mentre l'azione sul pulsante aveva l'evento associato al click del mouse), ridotto in una riga:</p>

<pre>
Platform.runLater( () -> metodoDaEseguire() ); 
</pre>

<p>In caso che il metodo da eseguire sia particolarmente breve possiamo anche direttamente scrivere:</p>
<pre>
Platform.runLater( () -> {
	// codice da eseguire
}); 
</pre>

</article>
</body>
</html>