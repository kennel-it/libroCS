<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html>
<!-- grafoIndice requires="maven API json http richiestaHttp rispostaHttp" group="servizi" -->
<!-- changelog 2023-04-11 inserito capitolo -->
<!-- changelog 2023-04-15 trattati parallelo MySQL e H2 -->
<!-- changelog 2023-04-15 messa definizione di microservizio -->
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta charset="UTF-8"/>
        <title>springBoot</title>
        <link type="text/css" rel="stylesheet" href="style.css"/>
        <script type="text/javascript" src="script/test.js"></script>
        <style>
            .h2::before, .mysql::before {
                background-size: contain;
                background-repeat: no-repeat;
                display: inline-block;
                content:"";
                height: 1em;
                width: 2em;
                margin: 0em 0.25em;
            }
            .h2 { background-color: #b9cafa}
            .h2::before { background-image: url('immagini/H2_logo.png') }
            .mysql {background-color: #ffc869}
            .mysql::before { background-image: url('immagini/mysql_logo.png') }
            section { padding:1em ; margin:1em 0}
            section.h2::before, section.mysql::before { height: 3em; width: 6em;}
        </style>
   </head>
<body>
<header>
    <h1>springBoot</h1>
    <p>scrivere velocemente dei micro servizi REST</p>
</header>
<article>
<h2>Architettura del sistema</h2>
<p>Dovendo costruire un sistema articolato nel suo progetto possiamo prendere
in considerazione due opposte soluzioni:
una architettura monolitica o una basata su microservizi.</p>

<p>Una <em>architettura monolitica</em> prevede che il sistema sia sviluppato come un unico
programma: un sistema di questo tipo ha alcuni vantaggi come la facilità iniziale di sviluppo,
la possibilità di ottimizzazione e la semplicità di fare test globali.
Ci sono però anche degli svantaggi: quando crescono sono più difficili da mantenere,
è difficile cambiare le tecnologie utilizzate e hanno bassa 
<a href="https://it.wikipedia.org/wiki/Scalabilit%C3%A0">scalabilità</a>.</p>

<p>In una <em>architettura a microservizi</em> non ho a che fare con una entità unica ma con più
programmi che offrono singoli servizi, un po' seguendo l'idea "fai una sola cosa e falla bene".
Fondamentalmente usando questa architettura gruppi più piccoli si sviluppatori
possono lavorare su un singolo servizio che può essere rilasciato molto velocemente, i singoli
gruppi sono liberi di scegliere la tecnologia da usare e di cambiarla e oltre questo
gli errori che riaguardano un singolo servizio sono più facili da trovare.
Ovviamente c'è un rovescio della medaglia, ad esempio: il sistema non ha caratteristiche comuni,
ogni volta che si aggiunge un microservizio il gruppo di sviluppo si deve organizzare per suo conto.</p>

<p style="text-align: center"><img style="width:6sssssssss0vw"
src="immagini/monolitico_microservizi.png"
alt="diagramma sistema monolitico e microservizi"/></p>

<h2>Cosa è Spring Boot</h2>
<p><a href="">Spring Boot</a>
è una estensione del 
<a href="https://spring.io/">framework Spring</a> il cui scopo 
è di mettere facilmente in esecuzione micro servizi web scritti in Java.
Si tratta di un <a href="https://it.wikipedia.org/wiki/Framework">framework</a>
cioè di un insieme di componenti preconfezionati che facilita lo sviluppo
di software, spesso utilizzando specifiche strategie di sviluppo.</p>
<p>Un framework si differenzia da quelle che chiamiamo librerie in alcuni aspetti:</p>
<ul>
    <li>la modalità con cui si svolgono le operazioni è dettata dal framework
    e non da chi lo usa</li>
    <li>esistono una serie di comportamenti di default</li>
    <li>chi usa il framework può estendere le sue funzionalità ma non 
    modificarlo</li>
</ul>

<h2>Perché Spring Boot</h2>
<p>Non è certo l'unico framework per scrivere applicazioni web ma:</p>
<ul>
    <li>riduce di molto il tempo di sviluppo aumentando la produttività</li>
    <li>evita la scrittura parti di codice ripetitive e file di configurazione</li>
    <li>è molto facile accedere ai database e salvare oggetti Java</li> 
    <li>adotta una strategia "Opinionated Defaults Configuration", in pratica in base alle dipendenze decide
    delle configurazioni di default</li>
    <li>fornisce un server web integrato per sviluppare le applicazioni (tomcat o altri)</li>
</ul>

<p>Trattandosi di un framework faremo la sua conoscenza direttamente utilizzandolo!
Per evitare di confonderli con quelli di HTTP i "metodi" degli oggetti Java verranno
chiamati "funzioni".</p>

<h2>Prima applicazione Spring</h2>

<p>Quella che ci apprestiamo a realizzare è la parte server (o backend) di una
semplice applicazione per gestire una lista di cose da fare ( "todo" ).
Il sistema gestisce più liste ma di un solo utente: deve permettere sia di visualizzare le liste
che di fare ricerche che di inserire nuove cose da fare nelle liste che di cancellare delle voci.</p>
<p>Per rappresentare le informazioni forzando un po' la mano
(magari uno schema ER ben fatto prevederebbe più relazioni)
utilizziamo un singolo oggetto (e quindi avremo una singola tabella)
che rappresenta una cosa da fare con le seguenti proprietà:</p>
<ul>
    <li>lista: un modo per identificare diverse categorie di cose da fare, es: "casa" o "lavoro"</li>
    <li>cosa: è la cosa che deve essere fatta, es: "completare la presentazione"</li>
    <li>fatto: un booleano per dire se la cosa è stata fatta o meno</li>
</ul>
<p>Le richieste verso il server verranno fatte tutte via HTTP utilizzando i vari metodi possibili
in riferimento alle nostre cose da fare: ad esempio potremmo mandare una richiesta per cancellare
una specifica cossa da fare indicandone il suo id e utilizzando il metodo <code>DELETE</code>
di HTTP. Le singole "cose da fare" saranno mappate da delle URL, un esempio chiarirà il tutto:
<code>http://localhost:8080/<em>todo/4</em></code> è la "cosa da fare" che ha come id 4.
Se la richiesta HTTP verso la URL in esempio
verrà inviata utilizzando il metodo <code>GET</code> si avrà
come risposta la rappresentazione JSON della cosa da fare, se la richiesta sarà
inviata con <code>DELETE</code> la risorsa verrà cancellata, con <code>PUT</code>
potremmo inviare nel body della richiesta eventuali variazioni da applicare alle
"cosa da fare" numero 4.</p>
<p>Tutti gli oggetti verranno scambiati dal client al server e viceversa
rappresentandoli in JSON... perché è il metodo più utilizzato e 
perché Spring Boot lo fa in automatico.</p>

<p>Una scelta però la lasciamo aperta: il database.
Nel seguito di questo capitolo seguiremo per quanto riguarda il db due strade parallele, ovviamente
una volta scelto ne va seguita una sola! I due percorsi si possono riconoscere dai relativi colori.</p>
<p class="h2">Questo percorso riguarda l'uso del database 
<a href="https://www.h2database.com/html/main.html">H2</a> che verrà incluso
nell'applicazione e quindi non va installato a parte, percorso buono per fare delle prove.
H2 gestirà il database in memoria, database che quindi verrà
resettato ad ogni avvio del server.</p>
<p class="mysql">Questo percorso riguarda l'uso del server <a href="https://www.mysql.com/">MySQL</a>
(o volendo <a href="https://mariadb.org/download/">MariaDB</a>) che però deve essere già
stato installato e configurato, è la strata che normalmente si segue in un progetto funzionante
ma biosogna avere in esecuzione un server MySQL e saperlo configurare.</p>

<h3>Il progetto</h3>
<p>Creare un progetto Spring boot è davvero molto facile: si crea on-line
con <a href="https://start.spring.io/">Spring initializr</a> e poi si scarica.
Qui sotto è riportato il progetto del tutto configurato, a seguire la descrizione di ogni parte.</p>

<img src="immagini/spring_initializr.png" alt="Spring initializr configurato per il progetto di todo list"/>
<dl>
    <dt>Project [1]</dt>
    <dd>il tipo di progetto che deve essere creato, nel nostro caso
    un progetto gestito da Maven</dd>
    <dt>Language [2]</dt>
    <dd>questo è piuttosto evidente: il linguaggio che vorremo usare per scrivere il codice</dd>
    <dt>Spring Boot [3]</dt>
    <dd>la versione di Spring Boot da utilizzare, in genere è una buona scelta per i nuovi
    progetti prendere l'ultima versione escludendo i vari SNAPSHOT e Milestone se
    non si è assolutamente sicuri di quel che si sta facendo</dd>
    <dt>Project Metadata [4]</dt>
    <dd>sono i dati descrittivi del progetto, gli stessi usati da Maven per
    identificarlo e descriverlo</dd>
    <dt>Packaging [5]</dt>
    <dd>il tipo di pacchetto che vogliamo venga prodotto: il "jar" contiene tutto quanto serve 
    per essere avviato su una Java Virtiual Machine, il "war" va invece caricato su un application server
    tipo Tomcat</dd>
    <dt>Java [6]</dt>
    <dd>la versione di Java che vogliamo usare, qui mettere l'ultima potrebbe non essere 
    una buona idea: nella figura sono presentate soltanto alcune versioni: 8, 11 e 17 sono
    versioni con supporto al lungo termine (meglio prendere l'ultima di queste se possibile)
    mentre la 20 è l'ultima versione uscita</dd>
    <dt>Dependencies [7]</dt>
    <dd>facendo click su questo pulsante si possono aggiungere le dipendenze al progetto,
    a noi ne servono alcune che sono descritte qui sotto ma ne esistono tantissime:
        <ul>
            <li>Spring Web: quello che tra le altre cose ci permette di creare servizi 
            web di tipo REST e usare Tomcat</li>
            <li>Spring Data JPA: un modo semplice per comunicare con i database, 
            serve poi un driver per un database specifico</li>
            <li class="h2">H2 Database: in questo caso come DB usiamo H2</li>
            <li class="mysql">MySQL JDBC driver: una liberia che consente
            di dialogare con un server MySQL.</li>
        </ul>
    </dd>
    <dt>GENERATE [8]</dt>
    <dd>click qui per scaricare un file zip che contiene tutto il progetto,
    questo file andrà poi scompattato e importato in Eclipse</dd>

</dl>


<h3>IDE</h3>
<p>Usiamo Eclipse (nella versione " Eclipse IDE for Enterprise Java and Web Developers")
per cui è disponibile una estensione per Spring Boot: click sul menu "/help/Eclipse Marketplace..."
e nella casella "find" scrivere <em>Spring Tools</em> e installare "Spring Tools 4",
a questo punto verrà installata l'estensione.</p>
<p>Nota: nella scrittura di applicazioni Spring Boot è spesso necessario fermare e poi riavviare
le applicazioni: in Eclipse conviene usare
<img src="immagini/eclipse_relaunch.png" alt="icona del pulsante relaunch in Eclipse" style="height:1em"/></p>


<h2>Configurazione del progetto</h2>
<p>Ne serve pochissima, fa quasi tutto Spring da solo, anche regolandosi in base
alle dipendenze, in pratica nel nostro caso la sola configurazione da fare
riguarda l'accesso ai dati.</p>
<p>La configurazione va scritta nel file <code>application.properties</code>
che si trova nella cartella <code>src/main/resources</code> (è un file per il funzionamento 
del programma e non per il test quindi sta in "main", non essendo un file java sta in resources).</p>
<p>Il formato del file è il solito <em>nome_proprietà=valore</em>,
i commenti sono inseriti utilizzando il simbolo <em>#</em>.</p>


<section class="h2">
<p>Il file di configurazione qui sotto è per H2, ridotto al minimo:</p>

<pre><em># l'indirizzo del database a cui connettersi, il modo di scriverlo cambia da db a db</em>
spring.datasource.url=jdbc:h2:mem:todolist

<em># serve soltanto per H2 o per gli altri database "in memory"
# per cui se non si mette questa le tabelle vengono create al volo
# all'avvio dell'applicazione in base agli oggetti che definiremo, siccome io
# voglio creare le tabelle e inserire dei dati non voglio che queste
# vengano create da Spring quindi metto questa riga, normalmente non serve</em>
spring.jpa.hibernate.ddl-auto=none

<em># questa è soltanto per comodità visto che usiamo H2, questo db permette di
# avere una console accessibile via web aggiungendo "/h2-console" 
# (una cosa tipo phpmyadmin) all'indirizzo del server
# ad esempio: "http://localhost:8080/h2-console"</em>
spring.h2.console.enabled=true
</pre>

<h3>database</h3>
<p>Dobbiamo istruire il sistema per creare il database all'avvio,
fortunatamente basta inserire un paio di file di configurazione
nella cartella <code>src/main/resources</code>, i file sono quelli qui sotto.</p>

<h4>schema.sql</h4> 
<p>La creazione delle tabelle</p>
<pre>CREATE TABLE todo(
    id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,
    lista VARCHAR(20),
    cosa VARCHAR(200),
    fatto BOOLEAN
);</pre>

<h4>data.sql</h4>
<p>Per poter testare l'applicazioni farebbe comodo avere anche dei dati caricati nel db,
facile: mettiamo le insert in questo file</p>
<pre>INSERT INTO todo (lista, cosa, fatto) VALUES ('casa', 'pulire', false);
INSERT INTO todo (lista, cosa, fatto) VALUES ('casa', 'comperare fagioli', false);
INSERT INTO todo (lista, cosa, fatto) VALUES ('hobby', 'pagare palestra', true);
INSERT INTO todo (lista, cosa, fatto) VALUES ('hobby', 'pulire scarpe', true);
INSERT INTO todo (lista, cosa, fatto) VALUES ('lavoro', 'studiare Napoleone', false);
INSERT INTO todo (lista, cosa, fatto) VALUES ('lavoro', 'sconsegnare relazione', true);
INSERT INTO todo (lista, cosa, fatto) VALUES ('lavoro', 'pulire armadietto', false);
</pre>

</section>

<section class="mysql">
<p>Il database è un server esterno (che se qualcuno non ha configurato per noi dobbiamo
installare e configurare), quel che abbiamo nei nel progetto Spring è semplicemente
un modo per collegarci con lui. In particolare dobbiamo aver creato
(usando phpMyAdmin o altro strumento):</p>
<ul>
    <li>un database chiamato <code>todo</code></li>
    <li>un utente chiamato <code>utente</code> con password <code>chiave</code> con accesso al db</li>
    <li>il database deve avere la tabella <code>todo</code> con dei dati preinseriti,
    per comodità sono riportate sotto le istruzioni per crearlo e inserire i dati.</li>
</ul>
<pre>CREATE TABLE todo(
    id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,
    lista VARCHAR(20),
    cosa VARCHAR(200),
    fatto BOOLEAN
);
INSERT INTO todo (lista, cosa, fatto) VALUES ('casa', 'pulire', false);
INSERT INTO todo (lista, cosa, fatto) VALUES ('casa', 'comperare fagioli', false);
INSERT INTO todo (lista, cosa, fatto) VALUES ('hobby', 'pagare palestra', true);
INSERT INTO todo (lista, cosa, fatto) VALUES ('hobby', 'pulire scarpe', true);
INSERT INTO todo (lista, cosa, fatto) VALUES ('lavoro', 'studiare Napoleone', false);
INSERT INTO todo (lista, cosa, fatto) VALUES ('lavoro', 'sconsegnare relazione', true);
INSERT INTO todo (lista, cosa, fatto) VALUES ('lavoro', 'pulire armadietto', false);
</pre>

<p>Le impostazioni da inserire in <code>application.properties</code> sono queste:</p>

<pre><em># l'indirizzo del database a cui connettersi, il modo di scriverlo cambia da db a db,
in questo caso supponiamo che il server MySQL sia in esecuzione sullo stesso host
dell'applicazione Spring</em>
jdbc:mysql://localhost:3306/todo
<em># soliti username e password per la connessione al db</em>
spring.datasource.username=utente
spring.datasource.password=chiave
</pre>

</section>



<h2>Programma</h2>
<p>Il programma vero e proprio è composto da 4 classi, 
la struttura è ovviamente semplificata (tutti i dati gestiti dal programma
sono rappresentati da un solo oggetto) ma ci sono tutti i ruoli presenti
in applicazioni più grandi: il modello dei ditai (la "cosa da fare"),
la rappresentazione dei dati completamente gestita da Spring in JSON sia in
input che in output e un controllore delle operazioni!</p>

<h3>Il modello dei dati</h3>
<pre>package it.aspix.todolist;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity(name = "todo")
public class ToDo {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Integer id;
    
    String lista;
    String cosa;
    Boolean fatto;

    /* il metodi set/get vanno inseriti per esercizio, magari usando Eclipse */
}
</pre>
<p>Un normalissimo oggetto Java con alcune accortezze. Concentriamoci adesso
sulle annotazioni (quelle strane cose che iniziano con @) che permettono 
a Spring di gestire l'intero progetto. Ogni annotazione è legata all'istruzione che la segue:
<code>@Entity</code> è relativa alla definizione della classe e in questo caso sta
a marcare che <code>ToDo</code> è un oggetto che JPA dovrà gestire in relazione 
al database relazionale che stiamo usando (H2 nel nostro caso, ma se fosse un altro
non cambierebbe nulla), l'atrributo <code>name</code> indica il nome della tabella nel database,
in genere non è necessario ma in questo caso si. Per default un oggetto "ToDo"
dovrebbe trovarsi nel db in una tabella chiamata "to_do" siccome così non è dobbiamo
specificare il nome della tabella, altrimenti non sarebbe statio necessario
(il camelCase viene tradotto con gli "_").</p>
<p><code>@Id</code> marca l'attributo che è chiave primaria e il 
successivo <code>@GeneratedValue</code> con il suo attributo <code>strategy</code> indicano
che la colonna sul db è di tipo auto_increment.</p>
<p>Una ultima cosa da notare: l'attributo <code>id</code> è di tipo <code>Integer</code>
e non <code>int</code>, questo perché vogliamo che l'attributo possa essere null
(fa comodo quando si fanno le ricerche),
questo non sarebbe possibile con il tipo int, stesso discorso vale per
<code>Boolean fatto</code>.</p>

<h3>Interfaccia verso il db</h3>
<p>Questa è probabilmente la classe più strana... in effetti non è neanche
una classe ma una interfaccia: poi tutto il lavoro lo fa Spring.</p>

<pre>package it.aspix.todolist;
import java.util.List;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface ToDoRepository extends JpaRepository&lt;ToDo, Integer&gt;{
    @Query(value="SELECT todo.* "+
            "FROM todo "+
            "WHERE todo.cosa ILIKE :parte", 
       nativeQuery=true)
    List&lt;ToDo&gt; cerca(@Param("parte") String parteDelCosa);
}</pre>

<p>L'unica parte davvero essenziale è la sola dichiarazione dell'interfaccia,
va fatta sempre in questo modo per ogni oggetto che vogliamo recuperare/salvare
nel db, <code>JpaRepository</code> è un tipo generico e deve avere come
parametri due cose: il tipo dell'oggetto che stiamo considerando e il tipo della sua chiave.</p>

<p>In questa interfaccia è presente però anche la funzione <code>cerca()</code>
che ci serve per poter fare un tipo particolare di ricerca: una ricerca per approssimazione.
L'annotazione <code>@Query</code> serve per specificare la query da eseguire e il suo
parametro <code>nativeQuery</code> impostato a true nel nostro caso è essenziale perché
stiamo scrivendo la query in SQL (e per uno specifico motore di database,
se usiamo una nsintassi valida solo per uno specifico database in caso che volessimo
cambiarlo dovremmo riscrivere la query),
se non lo avessimo messo avremmo dovuto
usare la sintassi JPA nella query che è leggermente diversa da quella di SQL.
Due cose da notare sul come è scritta la query:</p>
<ol>
    <li>il metodo ha un un parametro <code>parte</code> che viene passato alla funzione e inserito 
    nella query sopra utilizzando la sintassi <code>:parte</code></li>
    <li>vengono selezionati tutti i campi dell'oggetto in questione scrivendo
    <code>SELECT todo.*</code></li>
</ol>

<h3>Il gestore delle azioni possibili</h3>
<p>In questa classe definiamo cosa la nostra applicazione può fare,
lo facciamo dicendo a quali metodi di HTTP e a quali URL risponde.
Ogni funzione della classe riponde ad un particolare metodo+percorso di HTTP,
il tutto viene specificato tramite annotazioni prima delle funzioni Java.</p>
<p>I dati vengono leggi in input e inviati al client in output
in JSON sebbene non ci sia traccia di questo perché fa tutto
Spring Boot senza nessun intervento da parte nostra.</p>

<pre>package it.aspix.todolist;

import java.util.List;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Example;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ResponseStatusException;

<em>@RestController</em>
public class ToDoManager {

    @Autowired
    ToDoRepository repoToDo;

    @GetMapping("/todolist")
    public List&lt;ToDo&gt; elenco() {
        List&lt;ToDo&gt; k = repoToDo.findAll();
        return k;
    }

    @GetMapping("/cerca1")
    public List&lt;ToDo&gt; cerca(
        @RequestParam(required = false) String lista,
        @RequestParam(required = false) Boolean fatto
    ) {
        ToDo t = new ToDo();
        t.setLista(lista);
        t.setFatto(fatto);
        Example&lt;ToDo&gt; example = Example.of(t);
        return repoToDo.findAll( example );
    }

    @GetMapping("/cerca2")
    public List&lt;ToDo&gt; cercaParte( @RequestParam String cosa){
        return repoToDo.cerca("%"+cosa+"%");
    }

    @GetMapping("todo/{id}")
    public Optional&lt;ToDo&gt; prendiPerChiave( @PathVariable int id ) {
        return repoToDo.findById(id);
    }

    @PostMapping("/todo")
    public void inserisci(@RequestBody ToDo td) {
        repoToDo.save( td );
    }

    @DeleteMapping("todo/{id}")
    public void cancellaPerChiave( @PathVariable int id ) {
        repoToDo.deleteById(id);
    }

    @PutMapping("todo/{id}")
    public void modifica( @PathVariable int id, @RequestBody ToDo td ) {
        Optional&lt;ToDo&gt; k = repoToDo.findById(id);
        if(k.isPresent()) {
            ToDo t = k.get();
            t.setLista(td.getLista());
            t.setFatto(td.isFatto());
            t.setCosa(td.getCosa());
            repoToDo.save(t);
        } else {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND);
        }
    }
}</pre>

<p>Al soilito tante cose vengono risolte dalle annotazioni: <code>@RestController</code>
indica che questa classe offre servizi di tipo REST mentre <code>@Autowired</code>
fa una cosa un pochino più complicata. <code>ToDoRepository repoToDo</code> dichiara una
variabile ma non c'è traccia di costruzione dell'oggetto: questo perché Spring
usa una tecnica chiamata "Dependency Injection" che in pratica significa che l'oggetto
del titpo giusto lo crea Spring e quando la nostra classe funzionerà avrà una
istanza di ToDoRepository da poter utilizzare.</p>

<p>Vediamo i singoli metodi uno per uno, poniamo per semplicità che il 
server andrà in esecuzione sulla macchina locale alla porta usuale (8080).</p>

<h4>elenco()</h4>
<pre>@GetMapping("/todolist")
public List&lt;ToDo&gt; elenco() {
    List&lt;ToDo&gt; k = repoToDo.findAll();
    return k;
}</pre>
<p><code>@GetMapping</code> indica due cose: che la funzione elenco() risponde al metodo
GET di HTTTP e che risponde alla URL "/todolist"... più facile a farsi che a dirsi
"http://localhost:8080/todolist" e otterremo un elenco di tutte le cose da fare.</p>
<p>Il metodo in questione ritorna una lista di oggetti di tipo ToDo poi ci penserà
Spring a rappresentarli come JSON. Per recuperare gli oggetti dal DB usa il metodo
findAll() del nostro <code>repoToDo</code> (NB: che non abbiamo mai scritto,
fa tutto Spring).</p>

<h4>cerca1()</h4>
<pre>@GetMapping("/cerca1")
public List&lt;ToDo&gt; cerca(
    @RequestParam(required = false) String lista,
    @RequestParam(required = false) Boolean fatto
) {
    ToDo t = new ToDo();
    t.setLista(lista);
    t.setFatto(fatto);
    Example&lt;ToDo&gt; esempioDaCercare = Example.of(t);
    return repoToDo.findAll( esempioDaCercare );
}</pre>
<p>Il <code>@GetMapping</code> è analogo al precedente ma questa volta la funzione cerca()
ha due parametri: <code>lista</code> e <code>fatto</code>. 
<code>@RequestParam</code> serve per indicare
che ciascuno dei due parametri è opzionalmente presente come parametro della URL,
di nuovo alcuni esempi saranno chiarificatori: potremmo usare
"http://localhost:8080/cerca1?lista=casa" oppure "http://localhost:8080/cerca1" o anche
"http://localhost:8080/cerca1?lista=casa&amp;fatto=false".</p>
<p>Quello che fa la funzione è di chiedere a <code>repoToDo</code> di fare
una ricerca fornendo un esempio di quello che vogliamo cercare, le prime 4 linee del
metodo servono appunto a creare l'esempio!
Creo l'oggetto <code>t</code> e imposto due dei suoi campi (eventualmente a null se non 
erano presenti nella richiesta), poi con <code>Example.of(t)</code> creo un "Esempio"
da fornire alla funzione di ricerca.</p>

<h4>cerca2()</h4>
<pre>@GetMapping("/cerca2")
public List&lt;ToDo&gt; cercaParte( @RequestParam String cosa ){
    return repoToDo.cerca("%"+cosa+"%");
}</pre>
<p>Questa funzione risponde ad un richiesta GET alla url "/cerca2" che però
deve avere obbligatoriamente il parametro "cosa" in quanto <code>@RequestParam</code>
questa volta non ha il parametro <code>required = false</code>. Per svolgere la ricerca 
usa la funzione <code>cerca()</code> che abbiamo dichiarato in ToDoManager.</p>
<p>Un esempio di URL: "http://localhost:8080/cerca2?cosa=pulire"</p>

<h4>prendiPerChiave()</h4>
<pre>@GetMapping("todo/{id}")
public Optional&lt;ToDo&gt; prendiPerChiave( @PathVariable int id ) {
    return repoToDo.findById(id);
}</pre>
<p>Qui la particolarità è come viene passato il parametro di ricerca:
tramite il percorso nella URL. 
<code>@PathVariable</code> sta appunto ad indicare che "id" è una parte
della URL. Per cercare l'elemento con id=4 dovremo
scrivere "http://localhost:8080/todo/1", poi la funzione esegue la ricerca
seguendo il solito schema.</p>

<h4>inserisci()</h4>
<pre>@PostMapping("/todo")
public void inserisci(@RequestBody ToDo td) {
    repoToDo.save( td );
}</pre>
<p>A differenza dei precedenti l'annotazione della funzione è
<code>@PostMapping</code> il che indica che l'azione HTTP richiesta
deve essere POST e l'altra annotazione <code>@RequestBody</code>
indica che l'oggetto da inserire (uno di tipo ToDo) deve
essere scritto nel corpo ovviamente in formato JSON!
L'unica istruzione della funzione serve a salvare l'oggetto nel DB.</p>
<p>Attenzione che questa richiesta non si può inviare inserendo la URL
nella barra del browser perché questa sarebbe una rchiesta GET,
bisogna usare uno strumento tipo PostMan o fare una richiesta asincrona, 
in ogni caso va inserita una rappresentazione JSON di un ToDo
nel corpo della richiesta.</p>

<h4>cancellaPerChiave()</h4>
<pre>@DeleteMapping("todo/{id}")
public void cancellaPerChiave( @PathVariable int id ) {
    repoToDo.deleteById(id);
}</pre>
<p>Questo metodo risponde ad una richiesta DELETE di HTTP e
cancella l'elemento il cui id è stato inserito nel path della richiesta.</p>
<p>"http://localhost:8080/todo/2" elimina l'elemento numero 2.
Anche per provare questo tipo di richiesta non si può usare la barra
degli indirizzi del browser.</p>

<h4>modifica()</h4>
<pre>@PutMapping("todo/{id}")
public void modifica( @PathVariable int id, @RequestBody ToDo td ) {
    Optional&lt;ToDo&gt; k = repoToDo.findById(id);
    if(k.isPresent()) {
        ToDo t = k.get();
        t.setLista(td.getLista());
        t.setFatto(td.isFatto());
        t.setCosa(td.getCosa());
        repoToDo.save(t);
    } else {
        throw new ResponseStatusException(HttpStatus.NOT_FOUND);
    }
}</pre>
<p>Sebbene la modalità di comunicazione dovrebbe ormai essere chiara
(richiesta PUT: la funzione prima di tutto recupera l'oggetto presente nel db con l'id specificato,
in caso che quell'oggetto esiste copia i dati forniti nell'oggetto
recuperato dal db e poi lo salva. Se l'oggetto non esiste ritorna una risposta 404.</p>

<h3>main!</h3>
<p>Anche un programma Spring Boot ha bisogno di un metodo main, noi lo metteremo
in una classe separata:</p>
<pre>package it.aspix.todolist;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class TodolistApplication {

    public static void main(String[] args) {
        SpringApplication.run(TodolistApplication.class, args);
    }

}</pre>

<p>Molto breve, il metodo main lancia l'applicazione Spring e la classe stessa
è marcata come <code>@SpringBootApplication</code> che indica a Spring di
dover fare tutte le configurazioni del caso, cercare i componenti dell'applicazione
(ad esempio la nostra classe ToDoListManager)...</p>
<p><em>A questo punto non resta che avviare l'applicazione.</em></p>

<p>Un'ultima cosa: se durante lo sviluppo qualcosa va storto ma non si riesce a capire
il perché potrebbe far comodo aprire un terminale nella cartella del progetto
e usare i comandi <code>mvn clean</code>, <code>mvn compile</code> e 
<code>mvn spring-boot:run</code> (poi per fermare il server CTRL+C).</p>
</article>
</body>
</html>