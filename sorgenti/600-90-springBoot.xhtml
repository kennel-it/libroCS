<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html>
<!-- grafoIndice requires="maven API json http richiestaHttp rispostaHttp" group="servizi" -->
<!-- changelog 2023-04-11 inserito capitolo -->
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta charset="UTF-8"/>
        <title>springBoot</title>
        <link type="text/css" rel="stylesheet" href="style.css"/>
        <script type="text/javascript" src="script/test.js"></script>
   </head>
<body>
<header>
    <h1>springBoot</h1>
    <p>scrivere velocemente dei servizi REST</p>
</header>
<article>
<p><a href="">Spring Boot</a>
è una estensione del 
<a href="https://spring.io/">framework Spring</a> il cui scopo 
è di mettere facilmente in esecuzione applicazioni web scritte in Java.
Si tratta di un <a href="https://it.wikipedia.org/wiki/Framework">framework</a>
cioè di un insieme di componenti preconfezionati che facilita lo sviluppo
di software, spesso utilizzando specifiche strategie di sviluppo.</p>
<p>Un framework si differenzia da quelle che chiamiamo librerie in alcuni aspetti:</p>
<ul>
    <li>la modalità con cui si svolgono le operazioni è dettata dal framework
    e non da chi lo usa</li>
    <li>esistono una serie di comportamenti di default</li>
    <li>chi usa il framework può estendere le sue funzionalità ma non 
    modificarlo</li>
</ul>

<h2>Perché Spring Boot</h2>
<p>Non è certo l'unico framework per scrivere applicazioni web ma:</p>
<ul>
    <li>riduce di molto il tempo di sviluppo aumentando la produttività</li>
    <li>evita la scrittura parti di codice ripetitive e file di configurazione</li>
    <li>è molto facile accedere ai database e salvare oggetti Java</li> 
    <li>adotta una strategia "Opinionated Defaults Configuration", in pratica in base alle dipendenze decide
    delle configurazioni di default</li>
    <li>fornisce un server web integrato per sviluppare le applicazioni (tomcat o altri)</li>
</ul>

<p>Trattandosi di un framework faremo la sua conoscenza direttamente utilizzandolo!
Quello che anddremo a realizzare è un sistema per la gestione di una lista di cose da fare.
Per evitare di confonderli con quelli di HTTP i "metodi" degli oggetti Java verranno
chiamati "funzioni".</p>

<h2>Creazione del progetto</h2>

<h3>Il progetto</h3>
<p>Creare un progetto Spring boot è davvero molto facile: si crea on-line
con <a href="https://start.spring.io/">Spring initializr</a> e poi si scarica.
Qui sotto è riportato il progetto del tutto configurato, a seguire la descrizione di ogni parte.</p>

<img src="immagini/spring_initializr.png" alt="Spring initializr configurato per il progetto di todo list"/>
<dl>
    <dt>Project [1]</dt>
    <dd>il tipo di progetto che deve essere creato, nel nostro caso
    un progetto gestito da Maven</dd>
    <dt>Language [2]</dt>
    <dd>questo è piuttosto evidente: il linguaggio che vorremo usare per scrivere il codice</dd>
    <dt>Spring Boot [3]</dt>
    <dd>la versione di Spring Boot da utilizzare, in genere è una buona scelta per i nuovi
    progetti prendere l'ultima versione escludendo i vari SNAPSHOT e Milestone se
    non si è assolutamente sicuri di quel che si sta facendo</dd>
    <dt>Project Metadata [4]</dt>
    <dd>sono i dati descrittivi del progetto, gli stessi usati da Maven per
    identificarlo e descriverlo</dd>
    <dt>Packaging [5]</dt>
    <dd>il tipo di pacchetto che vogliamo venga prodotto: il "jar" contiene tutto quanto serve 
    per essere avviato su una Java Virtiual Machine, il "war" va invece caricato su un application server
    tipo Tomcat</dd>
    <dt>Java [6]</dt>
    <dd>la versione di Java che vogliamo usare, qui mettere l'ultima potrebbe non essere 
    una buona idea: nella figura sono presentate soltanto alcune versioni: 8, 11 e 17 sono
    versioni con supporto al lungo termine (meglio prendere l'ultima di queste se possibile)
    mentre la 20 è l'ultima versione uscita</dd>
    <dt>Dependencies [7]</dt>
    <dd>facendo click su questo pulsante si possono aggiungere le dipendenze al progetto,
    a noi ne servono alcune che sono descritte qui sotto ma ne esistono tantissime:
        <ul>
            <li>Spring Web: quello che tra le altre cose ci permette di creare servizi 
            web di tipo REST e usare Tomcat</li>
            <li>Spring Data JPA: un modo semplice per comunicare con i database, 
            serve poi un driver per un database specifico</li>
            <li>H2 Database: in questo caso come DB usiamo H2 che ci permette di
            creare un database al volo (e senza scriverlo su disco e senza doverlo installare), 
            normalmente si utilizzerà qualcosa come "MySQL Driver"</li>
        </ul>
    </dd>
    <dt>GENERATE [8]</dt>
    <dd>click qui per scaricare un file zip che contiene tutto il progetto,
    questo file andrà poi scompattato e importato in Eclipse</dd>

</dl>


<h3>IDE</h3>
<p>Usiamo Eclipse (nella versione " Eclipse IDE for Enterprise Java and Web Developers")
per cui è disponibile una estensione per Spring Boot: click sul menu "/help/Eclipse Marketplace..."
e nella casella "find" scrivere <em>Spring Tools</em> e installare "Spring Tools 4",
a questo punto verrà installata l'estensione.</p>
<p>Nota: nella scrittura di applicazioni Spring Boot è spesso necessario fermare e poi riavviare
le applicazioni: in Eclipse conviene usare
<img src="immagini/eclipse_relaunch.png" alt="icona del pulsante relaunch in Eclipse" style="height:1em"/></p>


<h2>Configurazione del progetto</h2>
<h3>Spring</h3>
<p>Ne serve pochissima, fa quasi tutto Spring da solo, anche regolandosi in base
alle dipendenze (ad esempio visto che usiamo H2 cercherà di creare le tabelle lui in automatico)
ma qualcosa va configurato, non fosse altro l'accesso al db... e altre cose che ci fanno comodo.
La configurazione va scritta nel file <code>application.properties</code>
che si trova nella cartella <code>src/main/resources</code> (è un file per il funzionamento 
del programma e non per il test quindi sta in "main", non essendo un file java sta in resources).</p> 
<p>Delle configurazioni qui sotto molte sono opzionali perché le suppone Spring di
suo visto che usiamo H2, le vediamo in ogni caso perché possono servire cambiando DB,
il formato del file è il solito "nome=valore", prima di ogni riga c'è una breve spiegazione.</p> 

<pre>
<em># l'indirizzo del database a cui connettersi, il modo di scriverlo cambia da db a db,
# per MySQL un esempio è "jdbc:mysql://localhost:3306/nome_database"</em>
spring.datasource.url=jdbc:h2:mem:todolist
<em># soliti username e password per la connessione al db</em>
spring.datasource.username=nome
spring.datasource.password=chiave

<em># serve soltanto per H2 o per gli altri database "in memory"
# per cui se non si mette questa le tabelle vengono create al volo
# all'avvio dell'applicazione in base agli oggetti che definiremo, siccome io
# voglio creare le tabelle e inserire dei dati non voglio che queste
# vengano create da Spring quindi metto questa riga, normalmente non serve</em>
spring.jpa.hibernate.ddl-auto=none

<em># questa è soltanto per comodità visto che usiamo H2, questo db permette di
# avere una console accessibile via web aggiungendo "/h2-console" all'indirizzo del server
# ad esempio: "http://localhost:8080/h2-console"</em>
spring.h2.console.enabled=true
</pre>

<h3>database</h3>
<p>Questa parte serve soltanto qui per esercizio, normalmente il database esiste
e quindi non va creato!
Per semplicità noi utilizziamo un database con una singola tabella il cui significato dei 
campi dovrebbe essere chiarito dalle insert qui sotto.</p>
<p>I due file che seguono vanno inseriti nella cartella <code>src/main/resources</code>
e verranno eseguiti all'avvio dell'applicazine automaticamente.
Siccome H2 è un database in memoria ogni volta che il server
verrà ricaricato si ricomincerà da capo, comodo per fare delle prove!
Quando si andrà in produzione (quindi quando il sistema sarà funzionante e
accessibile al pubblico) useremo un db diverso come MySQL o PostgreSQL
e non avremo certo questi file.</p>

<h4>schema.sql</h4> 
<p>La creazione delle tabelle</p>
<pre>CREATE TABLE todo(
    id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,
    lista VARCHAR(20),
    cosa VARCHAR(200),
    fatto BOOLEAN
);</pre>

<h4>data.sql</h4>
<p>Per poter testare l'applicazioni farebbe comodo avere anche dei dati caricati nel db,
facile: mettiamo le insert in questo file</p>
<pre>INSERT INTO todo (lista, cosa, fatto) VALUES ('casa', 'pulire', false);
INSERT INTO todo (lista, cosa, fatto) VALUES ('casa', 'comperare fagioli', false);
INSERT INTO todo (lista, cosa, fatto) VALUES ('hobby', 'pagare palestra', true);
INSERT INTO todo (lista, cosa, fatto) VALUES ('hobby', 'pulire scarpe', true);
INSERT INTO todo (lista, cosa, fatto) VALUES ('lavoro', 'studiare Napoleone', false);
INSERT INTO todo (lista, cosa, fatto) VALUES ('lavoro', 'sconsegnare relazione', true);
INSERT INTO todo (lista, cosa, fatto) VALUES ('lavoro', 'pulire armadietto', false);
</pre>


<h2>Programma</h2>
<p>Il programma vero e proprio è composto da 4 classi, 
la struttura è ovviamente semplificata (tutti i dati gestiti dal programma
sono rappresentati da un solo oggetto) ma ci sono tutti i ruoli presenti
in applicazioni più grandi: il modello dei ditai (la "cosa da fare"),
la rappresentazione dei dati completamente gestita da Spring in JSON sia in
input che in output e un controllore delle operazioni!</p>

<h3>Il modello dei dati</h3>
<pre>package it.aspix.todolist;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity(name = "todo")
public class ToDo {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Integer id;
    
    String lista;
    String cosa;
    Boolean fatto;

    /* il metodi set/get vanno inseriti per esercizio, magari usando Eclipse */
}
</pre>
<p>Un normalissimo oggetto Java con alcune accortezze. Concentriamoci adesso
sulle annotazioni (quelle strane cose che iniziano con @) che permettono 
a Spring di gestire l'intero progetto. Ogni annotazione è legata all'istruzione che la segue:
<code>@Entity</code> è relativa alla definizione della classe e in questo caso sta
a marcare che <code>ToDo</code> è un oggetto che JPA dovrà gestire in relazione 
al database relazionale che stiamo usando (H2 nel nostro caso, ma se fosse un altro
non cambierebbe nulla), l'atrributo <code>name</code> indica il nome della tabella nel database,
in genere non è necessario ma in questo caso si. Per default un oggetto "ToDo"
dovrebbe trovarsi nel db in una tabella chiamata "to_do" siccome così non è dobbiamo
specificare il nome della tabella, altrimenti non sarebbe statio necessario
(il camelCase viene tradotto con gli "_").</p>
<p><code>@Id</code> marca l'attributo che è chiave primaria e il 
successivo <code>@GeneratedValue</code> con il suo attributo <code>strategy</code> indicano
che la colonna sul db è di tipo auto_increment.</p>
<p>Una ultima cosa da notare: l'attributo <code>id</code> è di tipo <code>Integer</code>
e non <code>int</code>, questo perché vogliamo che l'attributo possa essere null
(fa comodo quando si fanno le ricerche),
questo non sarebbe possibile con il tipo int, stesso discorso vale per
<code>Boolean fatto</code>.</p>

<h3>Interfaccia verso il db</h3>
<p>Questa è probabilmente la classe più strana... in effetti non è neanche
una classe ma una interfaccia: poi tutto il lavoro lo fa Spring.</p>

<pre>package it.aspix.todolist;
import java.util.List;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface ToDoRepository extends JpaRepository&lt;ToDo, Integer&gt;{
    @Query(value="SELECT todo.* "+
            "FROM todo "+
            "WHERE todo.cosa ILIKE :parte", 
       nativeQuery=true)
    List&lt;ToDo&gt; cerca(@Param("parte") String parteDelCosa);
}</pre>

<p>L'unica parte davvero essenziale è la sola dichiarazione dell'interfaccia,
va fatta sempre in questo modo per ogni oggetto che vogliamo recuperare/salvare
nel db, <code>JpaRepository</code> è un tipo generico e deve avere come
parametri due cose: il tipo dell'oggetto che stiamo considerando e il tipo della sua chiave.</p>

<p>In questa interfaccia è presente però anche la funzione <code>cerca()</code>
che ci serve per poter fare un tipo particolare di ricerca: una ricerca per approssimazione.
L'annotazione <code>@Query</code> serve per specificare la query da eseguire e il suo
parametro <code>nativeQuery</code> impostato a true nel nostro caso è essenziale perché
stiamo scrivendo la query in SQL, se non lo avessimo messo avremmo dovuto
usare la sintassi JPA nella query che è leggermente diversa da quella di SQL.
Due cose da notare sul come è scritta la query:</p>
<ol>
    <li>il metodo ha un un parametro <code>parte</code> che viene passato alla funzione e inserito 
    nella query sopra utilizzando la sintassi <code>:parte</code></li>
    <li>vengono selezionati tutti i campi dell'oggetto in questione scrivendo
    <code>SELECT todo.*</code></li>
</ol>

<h3>Il gestore delle azioni possibili</h3>
<p>In questa classe definiamo cosa la nostra applicazione può fare,
lo facciamo dicendo a quali metodi di HTTP e a quali URL risponde.
Ogni funzione della classe riponde ad un particolare metodo+percorso di HTTP,
il tutto viene specificato tramite annotazioni prima delle funzioni Java.</p>
<p>I dati vengono leggi in input e inviati al client in output
in JSON sebbene non ci sia traccia di questo perché fa tutto
Spring Boot senza nessun intervento da parte nostra.</p>

<pre>package it.aspix.todolist;

import java.util.List;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Example;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ResponseStatusException;

<em>@RestController</em>
public class ToDoManager {

    @Autowired
    ToDoRepository repoToDo;

    @GetMapping("/todolist")
    public List&lt;ToDo&gt; elenco() {
        List&lt;ToDo&gt; k = repoToDo.findAll();
        return k;
    }

    @GetMapping("/cerca1")
    public List&lt;ToDo&gt; cerca(
        @RequestParam(required = false) String lista,
        @RequestParam(required = false) Boolean fatto
    ) {
        ToDo t = new ToDo();
        t.setLista(lista);
        t.setFatto(fatto);
        Example&lt;ToDo&gt; example = Example.of(t);
        return repoToDo.findAll( example );
    }

    @GetMapping("/cerca2")
    public List&lt;ToDo&gt; cercaParte( @RequestParam String cosa){
        return repoToDo.cerca("%"+cosa+"%");
    }

    @GetMapping("todo/{id}")
    public Optional&lt;ToDo&gt; prendiPerChiave( @PathVariable int id ) {
        return repoToDo.findById(id);
    }

    @PostMapping("/todo")
    public void inserisci(@RequestBody ToDo td) {
        repoToDo.save( td );
    }

    @DeleteMapping("todo/{id}")
    public void cancellaPerChiave( @PathVariable int id ) {
        repoToDo.deleteById(id);
    }

    @PutMapping("todo/{id}")
    public void modifica( @PathVariable int id, @RequestBody ToDo td ) {
        Optional&lt;ToDo&gt; k = repoToDo.findById(id);
        if(k.isPresent()) {
            ToDo t = k.get();
            t.setLista(td.getLista());
            t.setFatto(td.isFatto());
            t.setCosa(td.getCosa());
            repoToDo.save(t);
        } else {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND);
        }
    }
}</pre>

<p>Al soilito tante cose vengono risolte dalle annotazioni: <code>@RestController</code>
indica che questa classe offre servizi di tipo REST mentre <code>@Autowired</code>
fa una cosa un pochino più complicata. <code>ToDoRepository repoToDo</code> dichiara una
variabile ma non c'è traccia di costruzione dell'oggetto: questo perché Spring
usa una tecnica chiamata "Dependency Injection" che in pratica significa che l'oggetto
del titpo giusto lo crea Spring e quando la nostra classe funzionerà avrà una
istanza di ToDoRepository da poter utilizzare.</p>

<p>Vediamo i singoli metodi uno per uno, poniamo per semplicità che il 
server andrà in esecuzione sulla macchina locale alla porta usuale (8080).</p>

<h4>elenco()</h4>
<pre>@GetMapping("/todolist")
public List&lt;ToDo&gt; elenco() {
    List&lt;ToDo&gt; k = repoToDo.findAll();
    return k;
}</pre>
<p><code>@GetMapping</code> indica due cose: che la funzione elenco() risponde al metodo
GET di HTTTP e che risponde alla URL "/todolist"... più facile a farsi che a dirsi
"http://localhost:8080/todolist" e otterremo un elenco di tutte le cose da fare.</p>
<p>Il metodo in questione ritorna una lista di oggetti di tipo ToDo poi ci penserà
Spring a rappresentarli come JSON. Per recuperare gli oggetti dal DB usa il metodo
findAll() del nostro <code>repoToDo</code> (NB: che non abbiamo mai scritto,
fa tutto Spring).</p>

<h4>cerca1()</h4>
<pre>@GetMapping("/cerca1")
public List&lt;ToDo&gt; cerca(
    @RequestParam(required = false) String lista,
    @RequestParam(required = false) Boolean fatto
) {
    ToDo t = new ToDo();
    t.setLista(lista);
    t.setFatto(fatto);
    Example&lt;ToDo&gt; esempioDaCercare = Example.of(t);
    return repoToDo.findAll( esempioDaCercare );
}</pre>
<p>Il <code>@GetMapping</code> è analogo al precedente ma questa volta la funzione cerca()
ha due parametri: <code>lista</code> e <code>fatto</code>. 
<code>@RequestParam</code> serve per indicare
che ciascuno dei due parametri è opzionalmente presente come parametro della URL,
di nuovo alcuni esempi saranno chiarificatori: potremmo usare
"http://localhost:8080/cerca1?lista=casa" oppure "http://localhost:8080/cerca1" o anche
"http://localhost:8080/cerca1?lista=casa&amp;fatto=false".</p>
<p>Quello che fa la funzione è di chiedere a <code>repoToDo</code> di fare
una ricerca fornendo un esempio di quello che vogliamo cercare, le prime 4 linee del
metodo servono appunto a creare l'esempio!
Creo l'oggetto <code>t</code> e imposto due dei suoi campi (eventualmente a null se non 
erano presenti nella richiesta), poi con <code>Example.of(t)</code> creo un "Esempio"
da fornire alla funzione di ricerca.</p>

<h4>cerca2()</h4>
<pre>@GetMapping("/cerca2")
public List&lt;ToDo&gt; cercaParte( @RequestParam String cosa ){
    return repoToDo.cerca("%"+cosa+"%");
}</pre>
<p>Questa funzione risponde ad un richiesta GET alla url "/cerca2" che però
deve avere obbligatoriamente il parametro "cosa" in quanto <code>@RequestParam</code>
questa volta non ha il parametro <code>required = false</code>. Per svolgere la ricerca 
usa la funzione <code>cerca()</code> che abbiamo dichiarato in ToDoManager.</p>
<p>Un esempio di URL: "http://localhost:8080/cerca2?cosa=pulire"</p>

<h4>prendiPerChiave()</h4>
<pre>@GetMapping("todo/{id}")
public Optional&lt;ToDo&gt; prendiPerChiave( @PathVariable int id ) {
    return repoToDo.findById(id);
}</pre>
<p>Qui la particolarità è come viene passato il parametro di ricerca:
tramite il percorso nella URL. 
<code>@PathVariable</code> sta appunto ad indicare che "id" è una parte
della URL. Per cercare l'elemento con id=4 dovremo
scrivere "http://localhost:8080/todo/1", poi la funzione esegue la ricerca
seguendo il solito schema.</p>

<h4>inserisci()</h4>
<pre>@PostMapping("/todo")
public void inserisci(@RequestBody ToDo td) {
    repoToDo.save( td );
}</pre>
<p>A differenza dei precedenti l'annotazione della funzione è
<code>@PostMapping</code> il che indica che l'azione HTTP richiesta
deve essere POST e l'altra annotazione <code>@RequestBody</code>
indica che l'oggetto da inserire (uno di tipo ToDo) deve
essere scritto nel corpo ovviamente in formato JSON!
L'unica istruzione della funzione serve a salvare l'oggetto nel DB.</p>
<p>Attenzione che questa richiesta non si può inviare inserendo la URL
nella barra del browser perché questa sarebbe una rchiesta GET,
bisogna usare uno strumento tipo PostMan o fare una richiesta asincrona, 
in ogni caso va inserita una rappresentazione JSON di un ToDo
nel corpo della richiesta.</p>

<h4>cancellaPerChiave()</h4>
<pre>@DeleteMapping("todo/{id}")
public void cancellaPerChiave( @PathVariable int id ) {
    repoToDo.deleteById(id);
}</pre>
<p>Questo metodo risponde ad una richiesta DELETE di HTTP e
cancella l'elemento il cui id è stato inserito nel path della richiesta.</p>
<p>"http://localhost:8080/todo/2" elimina l'elemento numero 2.
Anche per provare questo tipo di richiesta non si può usare la barra
degli indirizzi del browser.</p>

<h4>modifica()</h4>
<pre>@PutMapping("todo/{id}")
public void modifica( @PathVariable int id, @RequestBody ToDo td ) {
    Optional&lt;ToDo&gt; k = repoToDo.findById(id);
    if(k.isPresent()) {
        ToDo t = k.get();
        t.setLista(td.getLista());
        t.setFatto(td.isFatto());
        t.setCosa(td.getCosa());
        repoToDo.save(t);
    } else {
        throw new ResponseStatusException(HttpStatus.NOT_FOUND);
    }
}</pre>
<p>Sebbene la modalità di comunicazione dovrebbe ormai essere chiara
(richiesta PUT: la funzione prima di tutto recupera l'oggetto presente nel db con l'id specificato,
in caso che quell'oggetto esiste copia i dati forniti nell'oggetto
recuperato dal db e poi lo salva. Se l'oggetto non esiste ritorna una risposta 404.</p>

<h3>main!</h3>
<p>Anche un programma Spring Boot ha bisogno di un metodo main, noi lo metteremo
in una classe separata:</p>
<pre>package it.aspix.todolist;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class TodolistApplication {

    public static void main(String[] args) {
        SpringApplication.run(TodolistApplication.class, args);
    }

}</pre>

<p>Molto breve, il metodo main lancia l'applicazione Spring e la classe stessa
è marcata come <code>@SpringBootApplication</code> che indica a Spring di
dover fare tutte le configurazioni del caso, cercare i componenti dell'applicazione
(ad esempio la nostra classe ToDoListManager)...</p>
<p><em>A questo punto non resta che avviare l'applicazione.</em></p>
</article>
</body>
</html>