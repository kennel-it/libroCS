<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html>
<!-- grafoIndice requires="springBootConfigurazione" group="spring" -->
<!-- changelog 2024-03-22 inserito capitolo separandolo da springBoot-->
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta charset="UTF-8"/>
        <title>springBoot</title>
        <link type="text/css" rel="stylesheet" href="style.css"/>
        <script type="text/javascript" src="script/test.js"></script>
        <style>
            .h2::before, .mysql::before {
                background-size: contain;
                background-repeat: no-repeat;
                display: inline-block;
                content:"";
                height: 1em;
                width: 2em;
                margin: 0em 0.25em;
            }
            .h2 { background-color: #b9cafa}
            .h2::before { background-image: url('immagini/H2_logo.png') }
            .mysql {background-color: #ffc869}
            .mysql::before { background-image: url('immagini/mysql_logo.png') }
            section { padding:1em ; margin:1em 0}
            section.h2::before, section.mysql::before { height: 3em; width: 6em;}
        </style>
   </head>
<body>
<header>
    <h1>springBootConfigurazione</h1>
    <p>setup iniziale del sistema</p>
</header>
<article>

<h2>Programma</h2>
<p>Il programma vero e proprio è composto da 4 classi, 
la struttura è ovviamente semplificata (tutti i dati gestiti dal programma
sono rappresentati da un solo oggetto) ma ci sono tutti i ruoli presenti
in applicazioni più grandi: il modello dei dati (la "gli oggetti da gestire"),
la rappresentazione dei dati completamente gestita da Spring in JSON sia in
input che in output e un controllore delle operazioni!</p>

<h3>Il modello dei dati</h3>
<pre>package it.aspix.todolist;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity(name = "todo")
public class ToDo {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Integer id;
    
    String lista;
    String cosa;
    Boolean fatto;

    /* il metodi set/get vanno inseriti per esercizio, magari usando Eclipse */
}
</pre>
<p>Un normalissimo oggetto Java con alcune accortezze. Concentriamoci adesso
sulle annotazioni (quelle strane cose che iniziano con @) che permettono 
a Spring di gestire l'intero progetto. Ogni annotazione è legata all'istruzione che la segue:
<code>@Entity</code> è relativa alla definizione della classe e in questo caso sta
a marcare che <code>ToDo</code> è un oggetto che JPA dovrà gestire in relazione 
al database relazionale che stiamo usando (H2 nel nostro caso, ma se fosse un altro
non cambierebbe nulla), l'atrributo <code>name</code> indica il nome della tabella nel database,
in genere non è necessario ma in questo caso si. Per default un oggetto "ToDo"
dovrebbe trovarsi nel db in una tabella chiamata "to_do" siccome così non è dobbiamo
specificare il nome della tabella, altrimenti non sarebbe stato necessario
(il camelCase viene tradotto con gli "_").</p>
<p><code>@Id</code> marca l'attributo che è chiave primaria e il 
successivo <code>@GeneratedValue</code> con il suo attributo <code>strategy</code> indicano
che la colonna sul db è di tipo auto_increment.</p>
<p>Una ultima cosa da notare: l'attributo <code>id</code> è di tipo <code>Integer</code>
e non <code>int</code>, questo perché vogliamo che l'attributo possa essere null
(fa comodo quando si fanno le ricerche),
questo non sarebbe possibile con il tipo int, stesso discorso vale per
<code>Boolean fatto</code>.</p>

<h3>Interfaccia verso il db</h3>
<p>Questa è probabilmente la classe più strana... in effetti non è neanche
una classe ma una interfaccia: poi tutto il lavoro lo fa Spring.</p>

<pre>package it.aspix.todolist;
import java.util.List;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface ToDoRepository extends JpaRepository&lt;ToDo, Integer&gt;{
    @Query(value="SELECT todo.* "+
            "FROM todo "+
            "WHERE todo.cosa ILIKE :parte", 
       nativeQuery=true)
    List&lt;ToDo&gt; cerca(@Param("parte") String parteDelCosa);
}</pre>

<p>L'unica parte davvero essenziale è la sola dichiarazione dell'interfaccia,
va fatta sempre in questo modo per ogni oggetto che vogliamo recuperare/salvare
nel db, <code>JpaRepository</code> è un tipo generico e deve avere come
parametri due cose: il tipo dell'oggetto che stiamo considerando e il tipo della sua chiave.</p>

<p>In questa interfaccia è presente però anche la funzione <code>cerca()</code>
che ci serve per poter fare un tipo particolare di ricerca: una ricerca per approssimazione.
L'annotazione <code>@Query</code> serve per specificare la query da eseguire e il suo
parametro <code>nativeQuery</code> impostato a true nel nostro caso è essenziale perché
stiamo scrivendo la query in SQL (e per uno specifico motore di database,
se usiamo una nsintassi valida solo per uno specifico database in caso che volessimo
cambiarlo dovremmo riscrivere la query),
se non lo avessimo messo avremmo dovuto
usare la sintassi JPA nella query che è leggermente diversa da quella di SQL
(e per questo non la trattiamo qui).
Due cose da notare sul come è scritta la query:</p>
<ol>
    <li>il metodo ha un un parametro <code>parte</code> che viene passato alla funzione e inserito 
    nella query sopra utilizzando la sintassi <code>:parte</code></li>
    <li>vengono selezionati tutti i campi dell'oggetto in questione scrivendo
    <code>SELECT todo.*</code></li>
</ol>

<h3>Il gestore delle azioni possibili</h3>
<p>In questa classe definiamo cosa la nostra applicazione può fare,
lo facciamo dicendo a quali metodi di HTTP e a quali URL risponde.
Ogni funzione della classe riponde ad un particolare metodo+percorso di HTTP,
il tutto viene specificato tramite annotazioni prima delle funzioni Java.</p>
<p>I dati vengono leggi in input e inviati al client in output
in JSON sebbene non ci sia traccia di questo perché fa tutto
Spring Boot senza nessun intervento da parte nostra.</p>

<pre>package it.aspix.todolist;

import java.util.List;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Example;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ResponseStatusException;

<em>@RestController</em>
public class ToDoManager {

    @Autowired
    ToDoRepository repoToDo;

    @GetMapping("/todolist")
    public List&lt;ToDo&gt; elenco() {
        List&lt;ToDo&gt; k = repoToDo.findAll();
        return k;
    }

    @GetMapping("/cerca1")
    public List&lt;ToDo&gt; cerca(
        @RequestParam(required = false) String lista,
        @RequestParam(required = false) Boolean fatto
    ) {
        ToDo t = new ToDo();
        t.setLista(lista);
        t.setFatto(fatto);
        Example&lt;ToDo&gt; example = Example.of(t);
        return repoToDo.findAll( example );
    }

    @GetMapping("/cerca2")
    public List&lt;ToDo&gt; cercaParte( @RequestParam String cosa){
        return repoToDo.cerca("%"+cosa+"%");
    }

    @GetMapping("todo/{id}")
    public Optional&lt;ToDo&gt; prendiPerChiave( @PathVariable int id ) {
        return repoToDo.findById(id);
    }

    @PostMapping("/todo")
    public void inserisci(@RequestBody ToDo td) {
        repoToDo.save( td );
    }

    @DeleteMapping("todo/{id}")
    public void cancellaPerChiave( @PathVariable int id ) {
        repoToDo.deleteById(id);
    }

    @PutMapping("todo/{id}")
    public void modifica( @PathVariable int id, @RequestBody ToDo td ) {
        Optional&lt;ToDo&gt; k = repoToDo.findById(id);
        if(k.isPresent()) {
            ToDo t = k.get();
            t.setLista(td.getLista());
            t.setFatto(td.isFatto());
            t.setCosa(td.getCosa());
            repoToDo.save(t);
        } else {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND);
        }
    }
}</pre>

<p>Al soilito tante cose vengono risolte dalle annotazioni: <code>@RestController</code>
indica che questa classe offre servizi di tipo REST mentre <code>@Autowired</code>
fa una cosa un pochino più complicata. <code>ToDoRepository repoToDo</code> dichiara una
variabile ma non c'è traccia di costruzione dell'oggetto: questo perché Spring
usa una tecnica chiamata "Dependency Injection" che in pratica significa che l'oggetto
del titpo giusto lo crea Spring e quando la nostra classe funzionerà avrà una
istanza di ToDoRepository da poter utilizzare.</p>

<p>Vediamo i singoli metodi uno per uno, poniamo per semplicità che il 
server andrà in esecuzione sulla macchina locale alla porta usuale (8080).</p>

<h4>elenco()</h4>
<pre>@GetMapping("/todolist")
public List&lt;ToDo&gt; elenco() {
    List&lt;ToDo&gt; k = repoToDo.findAll();
    return k;
}</pre>
<p><code>@GetMapping</code> indica due cose: che la funzione elenco() risponde al metodo
GET di HTTTP e che risponde alla URL "/todolist"... più facile a farsi che a dirsi
"http://localhost:8080/todolist" e otterremo un elenco di tutte le cose da fare.</p>
<p>Il metodo in questione ritorna una lista di oggetti di tipo ToDo poi ci penserà
Spring a rappresentarli come JSON. Per recuperare gli oggetti dal DB usa il metodo
findAll() del nostro <code>repoToDo</code> (NB: che non abbiamo mai scritto,
fa tutto Spring).</p>

<h4>cerca1()</h4>
<pre>@GetMapping("/cerca1")
public List&lt;ToDo&gt; cerca(
    @RequestParam(required = false) String lista,
    @RequestParam(required = false) Boolean fatto
) {
    ToDo t = new ToDo();
    t.setLista(lista);
    t.setFatto(fatto);
    Example&lt;ToDo&gt; esempioDaCercare = Example.of(t);
    return repoToDo.findAll( esempioDaCercare );
}</pre>
<p>Il <code>@GetMapping</code> è analogo al precedente ma questa volta la funzione cerca()
ha due parametri: <code>lista</code> e <code>fatto</code>. 
<code>@RequestParam</code> serve per indicare
che ciascuno dei due parametri è opzionalmente presente come parametro della URL,
di nuovo alcuni esempi saranno chiarificatori: potremmo usare
"http://localhost:8080/cerca1?lista=casa" oppure "http://localhost:8080/cerca1" o anche
"http://localhost:8080/cerca1?lista=casa&amp;fatto=false".</p>
<p>Quello che fa la funzione è di chiedere a <code>repoToDo</code> di fare
una ricerca fornendo un esempio di quello che vogliamo cercare, le prime 4 linee del
metodo servono appunto a creare l'esempio!
Creo l'oggetto <code>t</code> e imposto due dei suoi campi (eventualmente a null se non 
erano presenti nella richiesta), poi con <code>Example.of(t)</code> creo un "Esempio"
da fornire alla funzione di ricerca.</p>

<h4>cerca2()</h4>
<pre>@GetMapping("/cerca2")
public List&lt;ToDo&gt; cercaParte( @RequestParam String cosa ){
    return repoToDo.cerca("%"+cosa+"%");
}</pre>
<p>Questa funzione risponde ad un richiesta GET alla url "/cerca2" che però
deve avere obbligatoriamente il parametro "cosa" in quanto <code>@RequestParam</code>
questa volta non ha il parametro <code>required = false</code>. Per svolgere la ricerca 
usa la funzione <code>cerca()</code> che abbiamo dichiarato in ToDoManager.</p>
<p>Un esempio di URL: "http://localhost:8080/cerca2?cosa=pulire"</p>

<h4>prendiPerChiave()</h4>
<pre>@GetMapping("todo/{id}")
public Optional&lt;ToDo&gt; prendiPerChiave( @PathVariable int id ) {
    return repoToDo.findById(id);
}</pre>
<p>Qui la particolarità è come viene passato il parametro di ricerca:
tramite il percorso nella URL. 
<code>@PathVariable</code> sta appunto ad indicare che "id" è una parte
della URL. Per cercare l'elemento con id=4 dovremo
scrivere "http://localhost:8080/todo/1", poi la funzione esegue la ricerca
seguendo il solito schema.</p>

<h4>inserisci()</h4>
<pre>@PostMapping("/todo")
public void inserisci(@RequestBody ToDo td) {
    repoToDo.save( td );
}</pre>
<p>A differenza dei precedenti l'annotazione della funzione è
<code>@PostMapping</code> il che indica che l'azione HTTP richiesta
deve essere POST e l'altra annotazione <code>@RequestBody</code>
indica che l'oggetto da inserire (uno di tipo ToDo) deve
essere scritto nel corpo ovviamente in formato JSON!
L'unica istruzione della funzione serve a salvare l'oggetto nel DB.</p>
<p>Attenzione che questa richiesta non si può inviare inserendo la URL
nella barra del browser perché questa sarebbe una rchiesta GET,
bisogna usare uno strumento tipo PostMan o fare una richiesta asincrona, 
in ogni caso va inserita una rappresentazione JSON di un ToDo
nel corpo della richiesta.</p>

<h4>cancellaPerChiave()</h4>
<pre>@DeleteMapping("todo/{id}")
public void cancellaPerChiave( @PathVariable int id ) {
    repoToDo.deleteById(id);
}</pre>
<p>Questo metodo risponde ad una richiesta DELETE di HTTP e
cancella l'elemento il cui id è stato inserito nel path della richiesta.</p>
<p>"http://localhost:8080/todo/2" elimina l'elemento numero 2.
Anche per provare questo tipo di richiesta non si può usare la barra
degli indirizzi del browser.</p>

<h4>modifica()</h4>
<pre>@PutMapping("todo/{id}")
public void modifica( @PathVariable int id, @RequestBody ToDo td ) {
    Optional&lt;ToDo&gt; k = repoToDo.findById(id);
    if(k.isPresent()) {
        ToDo t = k.get();
        t.setLista(td.getLista());
        t.setFatto(td.isFatto());
        t.setCosa(td.getCosa());
        repoToDo.save(t);
    } else {
        throw new ResponseStatusException(HttpStatus.NOT_FOUND);
    }
}</pre>
<p>Sebbene la modalità di comunicazione dovrebbe ormai essere chiara
(richiesta PUT: la funzione prima di tutto recupera l'oggetto presente nel db con l'id specificato,
in caso che quell'oggetto esiste copia i dati forniti nell'oggetto
recuperato dal db e poi lo salva. Se l'oggetto non esiste ritorna una risposta 404.</p>

<h3>main!</h3>
<p>Anche un programma Spring Boot ha bisogno di un metodo main, noi lo metteremo
in una classe separata:</p>
<pre>package it.aspix.todolist;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class TodolistApplication {

    public static void main(String[] args) {
        SpringApplication.run(TodolistApplication.class, args);
    }

}</pre>

<p>Molto breve, il metodo main lancia l'applicazione Spring e la classe stessa
è marcata come <code>@SpringBootApplication</code> che indica a Spring di
dover fare tutte le configurazioni del caso, cercare i componenti dell'applicazione
(ad esempio la nostra classe ToDoListManager)...</p>
<p><em>A questo punto non resta che avviare l'applicazione.</em></p>

<h2>CORS</h2>
<p>Molte volte un sito chiede risorse ad altri siti, questa pratica viene chiamata 
<em>Cross-Origin Resource Sharing</em> e per default non è permessa dai browser 
per motivi di sicurezza.
Quando un oggetto come ad esempio <code>XMLHttpRequest</code> fa una richiesta verso un sito diverso
rispetto a quello da cui è stata caricato 
(cioè la URL della richiesta ha un diverso protocollo, indirizzo o porta) il 
browser controlla se il sito a cui è stata fatta la richiesta permette che altri siti interagiscano
con lui in base ad un header HTTP eventualmente presente nella risposta: 
<code>Access-Control-Allow-Origin</code>.
Se la richiesta CORS è permessa allora il browser recapita la risposta allo script 
altrimenti la richiesta da origine ad un errore.</p>
<p>Spring Boot ci mette a disposizione una annotazione che può essere inserita
prima della classe o dei singoli metodi per permettere al nostro sistema
di servire richieste CORS: <code>@CrossOrigin</code> 
(il nome completo è org.springframework.web.bind.annotation.CrossOrigin). Questa
annotazione inserisce nella risposta l'header richiesto per permettere ad uno script
presente in altri siti di chiedere dati al nostro sistema.
L'annotazione permette di essere più selettivi riguardo a chi può farci richieste,
alcuni articoli come
<a href="https://www.baeldung.com/spring-cors">questo su Baeldung</a>
forniscono ulteriori dettagli.</p>


<p style="background-color:#ffff77;padding:1em">Un'ultima cosa: se durante lo sviluppo qualcosa va storto ma non si riesce a capire
il perché potrebbe far comodo aprire un terminale nella cartella del progetto
e usare i comandi <code>mvn clean</code>, <code>mvn compile</code> e 
<code>mvn spring-boot:run</code> (poi per fermare il server CTRL+C).</p>
</article>
</body>
</html>